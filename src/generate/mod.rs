use crate::error::GenerateError;
use std::io::Write;

mod abstraction;
mod config;
mod utils;
use abstraction::{Arg, ArgAction, ClapCommand, Command, CommandMut};
pub use config::Config;
use utils::{gen_enum_name, gen_rust_name, to_screaming_snake_case, to_snake_case};

#[derive(Clone)]
pub(crate) struct Trace {
    cmd_id: String,
}

/// Generate the scaffold for your completion based on `clap` object.
/// After importing the generated code, you can call `CMD.supplement(args)` to get the completion result.
/// The end product looks like this:
///
/// ```ignore
/// mod def {
///    include!(concat!(env!("OUT_DIR"), "/definition.rs")); // File generated by `generate` function
/// }
///
/// fn main() {
///    // `args` looks like ["supplement-example", "git", "log", "--graph"]
///    // so we should skip the first arg
///    let args = std::env::args().skip(1);
///    let shell = supplement::Shell::Fish; // Assume we only use fish shell
///    let grp = def::CMD.supplement(args).unwrap();
///    let ready = match grp {
///        CompletionGroup::Ready(r) => {
///            // The easy path. No custom logic needed.
///            // e.g. Completing a subcommand or flag, like `git chec<TAB>`
///            // or completing something with candidate values, like `ls --color=<TAB>`
///            r
///        }
///        CompletionGroup::Unready { unready, id, value } => {
///            match id {
///                def::ID::FlagGitDir => {
///                    let comps = my_custom_completion(history, value);
///                    unready.to_ready(comps)
///                }
///                _ => unimplemented!("Some more custom logic...")
///            }
///        }
///    };
///    ready.print(shell, &mut std::io::stdout()).unwrap()
/// }
/// ```
///full example can be found in `supplement-example/src/main.rs`
pub fn generate(
    cmd: ClapCommand<'_>,
    mut config: Config,
    w: &mut impl Write,
) -> Result<(), GenerateError> {
    let mut cmd = CommandMut(cmd);
    cmd.build();
    let cmd = cmd.to_const();

    writeln!(w, "type GlobalID = ID;")?;
    generate_recur(&[], "", &mut config, &cmd, &[], w)?;
    config.check_unprocessed_config()
}

#[derive(Clone)]
struct GlobalFlag {
    level: usize,
    id: String,
    ignored: bool,
}

struct NameType(&'static str);
impl NameType {
    const FLAG: Self = NameType("Flag");
    const ARG: Self = NameType("Arg");
    const COMMAND: Self = NameType("CMD");
    const EXTERNAL: Self = NameType("EXTERNAL");
}
impl std::fmt::Display for NameType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

struct Join<I>(I);
impl<T, I> std::fmt::Display for Join<I>
where
    T: std::fmt::Display,
    I: Iterator<Item = T> + Clone,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut first = true;
        for t in self.0.clone() {
            if first {
                first = false;
            } else {
                write!(f, ", ")?;
            }
            write!(f, "{t}")?;
        }
        Ok(())
    }
}

enum FlagType {
    No,
    Single,
    Multi,
}
struct FlagDisplayHelper<'a> {
    id_name: &'a str,
    ty: FlagType,
    flag: Arg<'a>,
    strict: bool,

    prev: &'a [Trace],
}
impl<'a> FlagDisplayHelper<'a> {
    fn id_line_str(&self) -> String {
        let id_name = self.id_name;
        let id = self.flag.get_id().to_string();
        let id_type = match self.ty {
            FlagType::No => "NoVal",
            FlagType::Single => "SingleVal",
            FlagType::Multi => "MultiVal",
        };
        let (global_id, is_certain) = match self.ty {
            FlagType::No => ("", true),
            _ => ("<GlobalID>", !self.flag.get_possible_values().is_empty()),
        };
        let value = if is_certain {
            "new_certain(line!())".to_owned()
        } else {
            let value = utils::get_id_value(self.prev, NameType::FLAG, &id);
            format!("new({value})")
        };
        format!("pub const {id_name}: id::{id_type}{global_id} = id::{id_type}::{value};")
    }
    fn type_str(&self) -> Result<String, GenerateError> {
        let id_name = self.id_name;
        let id = self.flag.get_id().to_string();
        let s = match self.ty {
            FlagType::No => {
                format!("flag_type::Type::new_bool({id_name})")
            }
            _ => {
                let complete_with_equal = utils::compute_flag_equal(self.flag, self.strict)
                    .map_err(|msg| GenerateError::Strict { id, msg })?;
                let possible_values = self.flag.get_possible_values();
                let possible_values = Join(possible_values.iter().map(|p| {
                    let name = p.get_name();
                    let help = p.get_help().unwrap_or_default();
                    format!("(\"{name}\", \"{help}\")")
                }));
                format!(
                    "flag_type::Type::new_valued({id_name}.into(), {complete_with_equal}, &[{possible_values}])"
                )
            }
        };
        Ok(s)
    }
}

fn generate_args_in_cmd(
    indent: &str,
    cmd: &Command<'_>,
    prev: &[Trace],
    w: &mut impl Write,
) -> std::io::Result<Vec<(String, String)>> {
    let mut args_names = vec![];

    let ext_sub = if cmd.is_allow_external_subcommands_set() {
        log::debug!("generating external subcommand");
        let name = NameType::EXTERNAL.to_string();
        Some((name.clone(), name, std::usize::MAX))
    } else {
        None
    };
    let args = utils::args(cmd).map(|arg| {
        let name = arg.get_id().to_string();

        log::debug!("generating arg {}", name);

        let max_values = arg.get_max_num_args();
        let rust_name = gen_rust_name(NameType::ARG, &name);

        (name, rust_name, max_values)
    });
    let args = args.chain(ext_sub.into_iter());

    for (name, rust_name, max_values) in args {
        let id_name = to_screaming_snake_case(&format!("id_{name}"));
        let id_type = if max_values == 1 {
            "id::SingleVal"
        } else {
            "id::MultiVal"
        };
        let id_value = utils::get_id_value(prev, NameType::ARG, &name);
        writeln!(
            w,
            "\
{indent}pub const {id_name}: {id_type}<GlobalID> = {id_type}::new({id_value});
{indent}const {rust_name}: Arg<GlobalID> = Arg {{
{indent}    id: {id_name}.into(),
{indent}    max_values: {max_values},
{indent}}};"
        )?;

        args_names.push((rust_name, name));
    }

    Ok(args_names)
}

fn generate_flags_in_cmd(
    prev: &[Trace],
    indent: &str,
    config: &mut Config,
    cmd: &Command<'_>,
    global_flags: &mut Vec<GlobalFlag>,
    w: &mut impl Write,
) -> Result<Vec<(String, Option<String>)>, GenerateError> {
    let mut flag_names = vec![];

    for flag in utils::flags(cmd) {
        let name = flag.get_id().to_string();

        let ignored = config.is_ignored(prev, &name);

        if name == "help" {
            log::debug!("skipping help flag");
            continue;
        }

        let takes_values = flag.takes_values();
        let possible_values = flag.get_possible_values();
        let rust_name = gen_rust_name(NameType::FLAG, &name);
        if flag.is_global_set() {
            let level = prev.len();
            if let Some(prev_flag) = global_flags.iter().find(|f| &f.id == &name) {
                log::info!("get existing global flag {name}");
                if prev_flag.ignored {
                    continue;
                }
                let mut name = "super::".repeat(level - prev_flag.level);
                name += &rust_name;
                flag_names.push((name, None));
                continue;
            } else {
                log::info!("get new global flag {name}");
                global_flags.push(GlobalFlag {
                    level,
                    ignored,
                    id: name.clone(),
                });
            }
        }
        if ignored {
            continue;
        }

        log::debug!("generating flag {}", name);

        let shorts = flag.get_short_and_visible_aliases().unwrap_or_default();
        let longs = flag.get_long_and_visible_aliases().unwrap_or_default();

        let (once, ty) = match flag.get_action() {
            ArgAction::Count => (false, FlagType::No),
            ArgAction::Append => (false, FlagType::Multi),
            _ => {
                let once = !flag.is_global_set();
                if takes_values {
                    (once, FlagType::Single)
                } else {
                    // TODO: for `once`, should also check override self
                    (once, FlagType::No)
                }
            }
        };
        let description = utils::escape_help(&flag.get_help());

        let shorts = Join(shorts.iter().map(|s| format!("'{s}'")));
        let longs = Join(longs.iter().map(|s| format!("\"{s}\"")));
        let id_name = to_screaming_snake_case(&format!("id_{name}"));
        let flag_display_helper = FlagDisplayHelper {
            ty,
            flag,
            prev,
            id_name: &id_name,
            strict: config.is_strict(),
        };

        let is_certain = !takes_values || !possible_values.is_empty();
        let id_for_enum = if is_certain { None } else { Some(name) };

        let id_line = flag_display_helper.id_line_str();
        let type_str = flag_display_helper.type_str()?;

        writeln!(
            w,
            "\
{indent}{id_line}
{indent}const {rust_name}: Flag<GlobalID> = Flag {{
{indent}    short: &[{shorts}],
{indent}    long: &[{longs}],
{indent}    description: \"{description}\",
{indent}    once: {once},
{indent}    ty: {type_str},
{indent}}};"
        )?;
        flag_names.push((rust_name, id_for_enum));
    }
    Ok(flag_names)
}

fn generate_mod_name(name: &str) -> String {
    to_snake_case(&format!("{}", name))
}
fn generate_subcmd_names(
    prev: &[Trace],
    config: &mut Config,
    cmd: &Command<'_>,
) -> impl Iterator<Item = (String, String)> {
    utils::non_help_subcmd(cmd).filter_map(|c| {
        if config.is_ignored(prev, &c.get_name()) {
            None
        } else {
            let name = c.get_name().to_string();
            Some((generate_mod_name(&name), name))
        }
    })
}

fn generate_recur(
    prev: &[Trace],
    indent: &str,
    config: &mut Config,
    cmd: &Command<'_>,
    global_flags: &[GlobalFlag],
    w: &mut impl Write,
) -> Result<(), GenerateError> {
    let mut global_flags = global_flags.to_vec();
    let name = cmd.get_name();
    let description = utils::escape_help(&cmd.get_about().unwrap_or_default());
    let level = prev.len();
    {
        let inner_indent = format!("    {indent}");
        let indent = if level > 0 { &inner_indent } else { indent };

        if level > 0 {
            let pre = "super::".repeat(level);
            writeln!(w, "{indent}use {pre}GlobalID as GlobalID;")?;
        }
        writeln!(w, "{indent}use supplement::core::*;\n")?;

        let flags = generate_flags_in_cmd(prev, &indent, config, cmd, &mut global_flags, w)?;
        let args = generate_args_in_cmd(&indent, cmd, prev, w)?;
        let sub_cmds: Vec<_> = generate_subcmd_names(prev, config, cmd).collect();

        let cmd_name = NameType::COMMAND;

        writeln!(w, "{indent}#[derive(Clone, Copy, PartialEq, Eq, Debug)]")?;
        writeln!(w, "{indent}pub enum ID {{")?;
        for (_, name) in args.iter() {
            let name = gen_enum_name(NameType::ARG, name);
            writeln!(w, "{indent}    {name},")?;
        }
        for (_, name) in flags.iter() {
            if let Some(name) = name {
                let name = gen_enum_name(NameType::FLAG, name);
                writeln!(w, "{indent}    {name},")?;
            }
        }
        for (mod_name, name) in sub_cmds.iter() {
            let name = gen_enum_name(NameType::COMMAND, name);
            writeln!(w, "{indent}    {name}({mod_name}::ID),")?;
        }
        writeln!(w, "{indent}}}")?;

        let args = Join(args.iter().map(|x| &x.0));
        let flags = Join(flags.iter().map(|x| &x.0));
        let sub_cmds = Join(sub_cmds.iter().map(|(m, _)| format!("{m}::{cmd_name}")));
        let scope = if level == 0 { "" } else { "(super)" };

        writeln!(
            w,
            "\
{indent}pub{scope} const {cmd_name}: Command<GlobalID> = Command {{
{indent}    name: \"{name}\",
{indent}    description: \"{description}\",
{indent}    all_flags: &[{flags}],
{indent}    args: &[{args}],
{indent}    commands: &[{sub_cmds}],
{indent}}};"
        )?;

        for sub_cmd in utils::non_help_subcmd(cmd) {
            let cmd_id = sub_cmd.get_name().to_string();
            if config.is_ignored(&prev, &cmd_id) {
                continue;
            }

            writeln!(w, "{indent}pub mod {} {{", generate_mod_name(&cmd_id))?;
            let mut prev = prev.to_vec();
            prev.push(Trace { cmd_id });
            generate_recur(&prev, &indent, config, &sub_cmd, &global_flags, w)?;
            writeln!(w, "{indent}}}")?;
        }
    }
    Ok(())
}
